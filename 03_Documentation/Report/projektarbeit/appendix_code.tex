\chapter{Source codes}\label{appx:code}
% This appendix shows the source code which was self written SMs and auxiliar wrappers. For any other code, namely the one-wire and soes library, since 
% they are under the GNU* license, it is easy that the reader look for oneself the code:
% \begin{description}
%     \item[LED WS2812b Driver] Original version only for one channel and suited for **add the ST family** << ** mention in the challenges \ref{sec:leds}
%         that there was a DMA incompatibility within this two families. **refer to the porting guide provided by ST.
%     \item[One-Wire generic driver] Original compatible version which includes a sample that runs in a infinite while-loop.
%     \item[SOES Library] Original version without the low level functions. << *** Mention that originally the support for ST is not provided but only for: **look 
%         the processors natively supported. \ref{sec:soes}.
% \end{description}
This appendix enlists the fundamental source codes within this implementation. The order is as follows:
\begin{itemize}
    \item Configuration header file for the main features where the full list of errors and events can be seen in ~\ref{lst:definitions}.
    \item Code for the creation and configuration of threads plus some auxiliary functions in ~\ref{lst:generalSM}.
    \item Main code for the Event Handler in ~\ref{lst:event}.
    \item Main code for the ECAT DSM in ~\ref{lst:ecatSM}.
    \item Main code for the SOES DSM in ~\ref{lst:soesAPP}. 
    \item Main code for the LED DSM in ~\ref{lst:led}.
    \item Code for the Temperature Application in ~\ref{lst:tempApp}.
\end{itemize}

\begin{lstlisting}[label=lst:definitions,caption={Main definition and configuration header file.}]
    /*
    * AxisCommHub_definitions.h
    *
    *  Created on: Jun 11, 2020
    *      Author: Carlos Reyes
    */
   
   #ifndef AXISCOMMHUB_DEFINITIONS_H_
   #define AXISCOMMHUB_DEFINITIONS_H_
   
   
   //	General include files
   
   #include "LAN9252_spi.h"
   #include "main.h"
   
   //	Definition of peripherals
   #define	NUM_OF_SENSORS			15u
   
   #define MAX_OF_LEDRINGS			4		//	This values should be modified in the LED library
   #define NUM_OF_LEDRINGS			2
   #define NUM_OF_LEDS_PER_RING	5		//	If the number is not the same for all LED Rings, then change directly within the LED library
   
   //	Generic definitions
   #define	TRUE					1
   #define	FALSE					0
   #define FAILED					-1
   
   //	Timing for SOES
   #define SOES_REFRESH_CYCLE		20u		//in Systicks
   
   // 	Mind the following structure for event flags (See #define MAX_BITS_EVENT_GROUPS     24U)
   // | 8 reserved bits | 14 bits (16383d) error space | 10 bit individual event flags|
   
   //	Declaration of event flags (10 available)
   #define SYS_EVENT			(1<<0)
   #define LED_EVENT			(1<<1)
   #define TSENS_EVENT			(1<<2)
   #define ECAT_EVENT			(1<<3)
   #define	TASKM_EVENT			(1<<4)
   
   
   //	Offsets
   #define ERR_OFFSET				1000u
   #define EV_OFFSET				2000u
   #define	SHIFT_OFFSET			10u
   //	Declaration of errors
   #define	ERR_SYS_NONE			0
   #define	ERR_SYS_UNKNOWN			101
   
   
   #define	ERR_TEMP_SENS_INIT		 1101u
   #define ERR_TEMP_SENS_LOST		 1102u
   #define ERR_TEMP_SENS_TIMEOUT	 1103u
   #define ERR_TEMP_SENS_OVERHEAT	 1104u
   #define	ERR_TEMP_DSM_FAULT		 1105u
   
   #define ERR_LED_INIT		 	1201u
   #define ERR_LED_TIMEOUT		 	1202u
   #define ERR_LED_SEND		 	1203u
   #define	ERR_LED_OSTIM		 	1204u
   #define	ERR_LED_DSM_FAULT	 	1205u
   
   #define	ERR_ECAT_INIT			 1301u
   #define ERR_ECAT_COMM_LOST		 1302u
   #define ERR_ECAT_TIMEOUT		 1303u
   #define ERR_ECAT_DSM_FAULT		 1304u
   #define ERR_ECAT_CMD_FAULT		 1305u
   #define ERR_ECAT_CMD_SOFTFAULT	 1306u
   
   //	Definition of internal events
   #define EV_TEMP_DSM_INIT	 	2101
   
   #define EV_LED_DSM_INIT		 	2201
   #define EV_LED_UPTD			 	2211
   
   #define EV_ECAT_ESC_INIT		 2301
   #define EV_ECAT_APP_OP			 2311
   #define EV_ECAT_APP_INIT		 2312
   #define EV_ECAT_APP_NOOP		 2313
   #define EV_ECAT_DSM_INIT		 2321
   #define EV_SOES_RESPAWNED		 2331
   #define EV_ECAT_CMD_ACK			 2351
   #define EV_ECAT_CMD_LED_TOGGLE	 2352
   
   
   // 	Mind the following structure for status variable (according to size of errors and events (16383d))
   // | 14 bits last event space | 14 bits last error space | 4 bit General state |
   #define	STATUS_OFFSET_FOR_ERR	4u
   #define	STATUS_OFFSET_FOR_EV	18u
   
   #define STATUS_DATA_MASK		0x3FFF
   #define STATUS_SHORT_MASK		0x0F
   
   #define	STATUS_INIT				1u
   #define	STATUS_STARTED			2u
   #define	STATUS_NO_ERRORS		4u
   #define STATUS_SOFT_ERRORS		5u
   
   
   //	Definition of specific timeouts
   //	ECAT/SOES
   #define	ESC_INIT_TIMEOUT	5u
   #define	ESC_REFRESH_TIMEOUT	10000u
   
   //	Definitions of ETHERCAT STATE MACHINE
   //	See esc.h for ALstatus Reg
   //	e.g. ESCop
   
   //	Auxiliar definitions for HAL adaptation
   
   #define CHANNEL_FOR_LED1		TIM_CHANNEL_1
   #define CHANNEL_FOR_LED2		TIM_CHANNEL_2
   #define CHANNEL_ACTIVE_FOR_LED1	HAL_TIM_ACTIVE_CHANNEL_1
   #define CHANNEL_ACTIVE_FOR_LED2 HAL_TIM_ACTIVE_CHANNEL_2
   
   
   //	Overall test definitions
   
   #define ECAT_UPDT_PERIOD_TEST_IN_MS			10u	//1>> RT	10-15 >> Industrial RT 	100>> Non-critical variables monitoring
   #define	ECAT_CONNECTION_CHECK_PERIOD_IN_MS	10u
   #define	ECAT_CHECK_PERIOD_FACTOR			ECAT_CONNECTION_CHECK_PERIOD_IN_MS/ECAT_UPDT_PERIOD_TEST_IN_MS
   #define COMM_TESTING_TIMES					100u
   
   
   //	Taken from linux definitions and needed by SOES
   #define BIT(nr) (1UL << (nr))
   
   #endif /* AXISCOMMHUB_DEFINITIONS_H_ */
   

\end{lstlisting}

\begin{lstlisting}[label=lst:generalSM,caption={Part of the code to declare threads and other auxiliar functions.}]
    /*
    * SMs.c
    *
    *  Created on: Jun 3, 2020
    *      Author: Carlos Reyes
    */
   
   #include "main.h"
   #include "AxisCommHub_definitions.h"
   #include "SMs.h"
   #include "smEcat.h"
   
   extern osTimerId_t timerEcatSM,timerEcatSOES;
   
   /*-----------------------------------------------TASKS for SMs--------------------------------------------------------------*/
   // Task Handlers declared within the SMs.h
   
   
   uint32_t tempSensTBuffer[ 192 ];
   StaticTask_t tempSensTControlBlock;
   const osThreadAttr_t tempSensT_attributes = {
           .name = "tempSensT",
           .stack_mem = &tempSensTBuffer[0],
           .stack_size = sizeof(tempSensTBuffer),
           .cb_mem = &tempSensTControlBlock,
           .cb_size = sizeof(tempSensTControlBlock),
           .priority = (osPriority_t) osPriorityNormal,
   };
   
   
   uint32_t ledRingsTBuffer[ 192 ];
   StaticTask_t ledRingsTControlBlock;
   const osThreadAttr_t ledRingsT_attributes = {
           .name = "ledRingsT",
           .stack_mem = &ledRingsTBuffer[0],
           .stack_size = sizeof(ledRingsTBuffer),
           .cb_mem = &ledRingsTControlBlock,
           .cb_size = sizeof(ledRingsTControlBlock),
           .priority = (osPriority_t) osPriorityNormal,
   };
   
   
   uint32_t ecatSMTBuffer[ 192 ];
   StaticTask_t ecatSMTControlBlock;
   const osThreadAttr_t ecatSMT_attributes = {
           .name = "ecatTSM",
           .stack_mem = &ecatSMTBuffer[0],
           .stack_size = sizeof(ecatSMTBuffer),
           .cb_mem = &ecatSMTControlBlock,
           .cb_size = sizeof(ecatSMTControlBlock),
           .priority = (osPriority_t) osPriorityNormal,
   };
   
   
   uint32_t eventHTBuffer[ 128 ];
   StaticTask_t eventHTControlBlock;
   const osThreadAttr_t eventHT_attributes = {
           .name = "eventHT",
           .stack_mem = &eventHTBuffer[0],
           .stack_size = sizeof(eventHTBuffer),
           .cb_mem = &eventHTControlBlock,
           .cb_size = sizeof(eventHTControlBlock),
           .priority = (osPriority_t) osPriorityAboveNormal,
   };
   
   /*-----------------------------------------------AUXILIAR TASKS--------------------------------------------------------------*/
   
   /*-------------------------ECAT--------------------------------------*/
   uint32_t ecatTestTBuffer[ 192 ];
   StaticTask_t ecatTestTControlBlock;
   const osThreadAttr_t ecatTestT_Attributes = {
           .name = "ecatTestT",
           .stack_mem = &ecatTestTBuffer[0],
           .stack_size = sizeof(ecatTestTBuffer),
           .cb_mem = &ecatTestTControlBlock,
           .cb_size = sizeof(ecatTestTControlBlock),
           .priority = (osPriority_t) osPriorityHigh3,
   };
   
   uint32_t ecatSOESTBuffer[1088];
   StaticTask_t ecatSOESTControlBlock;
   const osThreadAttr_t ecatSOEST_Attrbuttes = {
           .name = "ecatSOEST",
           .stack_mem = ecatSOESTBuffer,
           .stack_size = sizeof(ecatSOESTBuffer),
           .cb_mem = &ecatSOESTControlBlock,
           .cb_size = sizeof(ecatSOESTControlBlock),
           .priority = (osPriority_t) osPriorityAboveNormal,
   };
   
   /*----------------------System Monitor--------------------------------*/
   
   uint32_t taskManagerTBuffer[ 192 ];
   StaticTask_t taskManagerTControlBlock;
   const osThreadAttr_t taskManagerT_Attributes = {
           .name = "taskManagerT",
           .stack_mem = &taskManagerTBuffer[0],
           .stack_size = sizeof(taskManagerTBuffer),
           .cb_mem = &taskManagerTControlBlock,
           .cb_size = sizeof(taskManagerTControlBlock),
           .priority = (osPriority_t) osPriorityHigh,
   };

  
   /******************************************* Extern Variables from LED Rings Multichannel *********************************************************************/
   
   //volatile uint8_t currentColors[MAX_OF_LEDRINGS];	//Global array for colors to be updated, this will be changed continuously by EventHandler/Notification //CHCKME this is shared memory
   extern volatile uint8_t dmaLed1_rcvd, dmaLed2_rcvd,refreshTimeoutLed;
  
   
   /******************************************* Variables to debug ****************************************************************/
   osStatus_t static ecatStatus,uartPrintStatus;
   uint32_t *heapObserver0,*heapObserver1,*heapObserver2;
   
   /*************************************** Var task manager ***********************************************************/
   static osThreadState_t status_ecatTestT, status_ecatT, status_evHT,status_uartPT,status_tSensT,status_ledsT, status_taskMT,status_ecatSOEST;
   osTimerId_t timerTsens;	//IMPRVME	This may be a local variable to save memory
   static uint8_t timedoutTsens;
   

   
   /*-------------------------Here start the definitions of the functions needed by SM --------------*/
   /*----------------------------------- Task Manager functions ---------------------------------------*/
   /* *
    * @brief 	This function will update the status for each task and terminate a thread if needed
    * */
   
   void taskManger(void * argument) {
   
       osStatus_t status;
       while (1) {
           if (restartTaskManFlag) {
               restartTaskManFlag = FALSE;
               osDelay(100);
               status = osThreadSuspend(ecatSOESTHandler);
               status = osThreadTerminate(ecatSOESTHandler);
               ecatSOESTHandler = osThreadNew(soes, NULL, &ecatSOEST_Attrbuttes);
               status = osThreadSuspend(ecatSOESTHandler);
               osEventFlagsSet(evt_sysSignals, TASKM_EVENT|EV_SOES_RESPAWNED);
           }
   
           status_ecatTestT = osThreadGetState(ecatTestTHandler);
           status_ecatT = osThreadGetState(ecatSMTHandle);
           status_ecatSOEST = osThreadGetState(ecatSOESTHandler);
   
           //osThreadYield();	//Yield to any other thread that may be ready
           //osDelay(1000);			//1ms update rate
           osEventFlagsWait(taskManSignals, TASKM_EVENT,osFlagsWaitAny , osWaitForever);
   
           status_ecatSOEST = osThreadGetState(ecatSOESTHandler);
           status_evHT = osThreadGetState(eventHTHandle);
           status_uartPT = osThreadGetState(uartPrintTHandler);
           status_tSensT = osThreadGetState(tempSensTHandle);
           status_ledsT = osThreadGetState(ledRingsTHandle);
           status_taskMT = osThreadGetState(taskManagerTHandler);
       }
   
       //osThreadTerminate(taskManagerTHandler);	//If ever jumps out the loop
   
   }
   
   /* *
    * @brief	This function adds the threads to be executed to the OS and the general signals
    * */
   void addThreads(void) {
       evt_sysSignals = osEventFlagsNew(NULL);
       if (evt_sysSignals == NULL){
           //Handle error
           __NOP();
       }
       taskManSignals = osEventFlagsNew(NULL);
       if (taskManSignals == NULL){
           //Handle error
           __NOP();
       }
   
       heapObserver0 = evt_sysSignals;
       heapObserver1 = taskManSignals;
   
       //	Initializing main threads
       tempSensTHandle = osThreadNew(tempSens_SM, NULL, &tempSensT_attributes);
       ledRingsTHandle = osThreadNew(ledRings_SM, NULL, &ledRingsT_attributes);
       ecatSMTHandle = osThreadNew(ecat_SM, NULL, &ecatSMT_attributes);
       eventHTHandle = osThreadNew(eventH_SM, NULL, &eventHT_attributes);
   
       //	Auxiliar tasks
   
       ecatSOESTHandler = osThreadNew(soes, NULL, &ecatSOEST_Attrbuttes);
       ecatStatus = osThreadSuspend(ecatSOESTHandler);
       taskManagerTHandler = osThreadNew(taskManger, NULL, &taskManagerT_Attributes);
   
       sysState = STATUS_INIT;
       //Debug tasks
       //eventTesterTHandler = osThreadNew(eventTesterTask,NULL,&eventTesterT_Attributes);	//Pending This task could start before the system is ready
   }

\end{lstlisting}

\begin{lstlisting}[label=lst:event,caption={Main source code for Event Handler DSM.}]
    /*
     * smEvH.c
     *
     *  Created on: Jun 26, 2020
     *      Author: Carlos Reyes
     */
    
    
    #include "SMs.h"
    #include "smEvH.h"
    
    
    //External variables
    
    
    /*
     * @brief Sate Machine for error/event handler
     *
     */
    
    void eventH_SM (void * argument) {
    
        uint32_t status,flags;	
        uint16_t event_data;
    
        while(1) {		//Infinite loop enforced by task execution
    
            switch (evH_step) {
            /*-------------------------------------------------------------------*/
            case	evh_init:
                evH_initFlag = TRUE;
                evH_step = evH_waiting;
                break;
            /*-------------------------------------------------------------------*/
            case	evH_waiting:
                //	entry:
                status = osEventFlagsWait(evt_sysSignals, SYS_EVENT, osFlagsWaitAny, osWaitForever);
                //	exit:
                evH_step = evH_check;
                break;
            /*-------------------------------------------------------------------*/
            case	evH_check:
                //	entry:
                status = osEventFlagsGet(evt_sysSignals);	//TODO check whether the flags are cleared
                event_data = (status>>SHIFT_OFFSET);
                if (event_data>EV_OFFSET) {
                    evH_step = evH_notifHandling;
                }
                else if (event_data>ERR_OFFSET) {
                    evH_step = evH_errHandling;
                }
                else {
                    __NOP();
                    evH_step = evH_error;
                }
    
                //	exit:
                break;
            /*-------------------------------------------------------------------*/
                case evH_errHandling:
                    //	entry:
                    if (event_data == ERR_ECAT_DSM_FAULT ||
                            ERR_ECAT_CMD_FAULT || ERR_LED_DSM_FAULT ||
                            ERR_TEMP_DSM_FAULT || ERR_TEMP_SENS_OVERHEAT ||
                            ERR_ECAT_COMM_LOST
                            ) {
                        //	PENDING Add an specific action depending on the error
                        errorFlag = TRUE;
                        normalFlag = FALSE;
                    }	//
                    else if (event_data == ERR_TEMP_SENS_LOST ||
                            ERR_ECAT_CMD_SOFTFAULT) {
                        //	PENDING Add an specific action depending on the warning
                        warningFlag = TRUE;
                        normalFlag = FALSE;
                    }
                    else {
                        //	do nothing
                        warningFlag = TRUE;
                        __NOP();
                        evH_step = evH_error;
                        break;
                    }
    
                    sysState &= ~(STATUS_DATA_MASK<<STATUS_OFFSET_FOR_ERR);
                    sysState |= ((event_data&STATUS_DATA_MASK)<<STATUS_OFFSET_FOR_ERR);
    
                    //exit
                    flags = osEventFlagsGet(evt_sysSignals);	//	SYS_EVENT flag is cleared while returning from eventsFlagWait functions
                    osEventFlagsClear(evt_sysSignals,flags);	//	Due to the priorities, it is not possible that another task creates events while this SM is running
                    evH_step = evH_waiting;
                    break;
            /*-------------------------------------------------------------------*/
                case evH_notifHandling:
                    //	entry:
                    if (event_data == EV_TEMP_DSM_INIT) {
                        //	If needed add an specific action depending on the notification
                        temp_initFlag = TRUE;
                    }	//
                    else if (event_data == EV_LED_DSM_INIT) {
                        //	If needed add an specific action depending on the notification
                        led_initFlag = TRUE;
                    }
                    else if (event_data == EV_ECAT_DSM_INIT) {
                        //	If needed add an specific action depending on the notification
                        ecat_initFlag = TRUE;
                    }
                    else if (event_data == EV_ECAT_CMD_ACK) {
                        //	Add an specific action depending on the ECAT cmd
                        sysState = 0xFF;
                        //evH_step = evH_ecatCMD;
                        //break;
                    }
                    else if (event_data == EV_ECAT_APP_OP) {
                        //	Add an specific action depending on the warning
                        if ((sysState&STATUS_SHORT_MASK) == STATUS_STARTED ) { //&& ((sysState>>STATUS_OFFSET_FOR_ERR) & STATUS_DATA_MASK) == ERR_SYS_NONE)
                            warningFlag = FALSE;
                            normalFlag = TRUE;
                            if(((sysState>>STATUS_OFFSET_FOR_ERR) & STATUS_DATA_MASK) == ERR_ECAT_COMM_LOST) {
                                errorFlag = FALSE;
                            }
                        }
    
                    }
                    else if (event_data == EV_ECAT_APP_INIT) {
                        //	If needed add an specific action depending on the notification
                        warningFlag = TRUE;
                        normalFlag = FALSE;
                    }
                    else if (event_data > EV_ECAT_CMD_ACK) {
                        //	PENDING This could be either an error or a warning or a shortcut to CMD step
                        //evH_step = evH_ecatCMD;
                        __NOP();
                    }
                    else {
                        //	do nothing
                        __NOP();
    
                        evH_step = evH_error;
                        break;
                    }
                    if ((sysState&STATUS_SHORT_MASK) == STATUS_INIT && temp_initFlag && led_initFlag && ecat_initFlag ) {
                        status = (sysState>>STATUS_OFFSET_FOR_ERR);	//	status used temporary
                        sysState = STATUS_STARTED|(status<<STATUS_OFFSET_FOR_ERR);
                    }
    
                    sysState &= ~(STATUS_DATA_MASK<<STATUS_OFFSET_FOR_EV);	//	Clearing the previous Event
                    sysState |= ((event_data&STATUS_DATA_MASK)<<STATUS_OFFSET_FOR_EV);
    
                    //exit
    
                    flags = osEventFlagsGet(evt_sysSignals);	//	SYS_EVENT flag is cleared while returning from eventsFlagWait functions
                    osEventFlagsClear(evt_sysSignals,flags);	//	Due to the priorities, it is not possible that another task creates events while this SM is running
                    evH_step = evH_waiting;
                    break;
            /*-------------------------------------------------------------------*/
                case	evH_ecatCMD:
                    //	entry:
                    //	PENDING An specific ecat command handler need to be defined
                    //eventHandled = TRUE; //Not needed so far since Flag is being cleared
                    __NOP();
    
                    //exit
                    status = SYS_EVENT |(event_data<<ERR_OFFSET);
                    osEventFlagsClear(evt_sysSignals, status);
                    evH_step = evH_waiting;
                    break;
            /*-------------------------------------------------------------------*/
                case	evH_error:
                    //	entry:
                    // This DSM terminates since an error in the event handler is critical and should be debugged by programmer.
                    errorFlag = TRUE;
                    sysState = ERR_SYS_UNKNOWN;
    
                    //	exit
                    osThreadSuspend(eventHTHandle);
                    break;
            /*-------------------------------------------------------------------*/
                default:
                    __NOP();
                }
        }
    
        //osThreadTerminate(eventHTHandle);
    
    
    }
\end{lstlisting}

\begin{lstlisting} [label=lst:ecatSM,caption={Main source code for ECAT DSM.}]
/*
 * smEcat.c
 *
 *  Created on: Jun 26, 2020
 *      Author: Carlos Reyes
 */

#include "SMs.h"
#include "smEcat.h"
#include "LAN9252_spi.h"
#include "esc.h"
#include "esc_hw.h"


/*--------------------Variable used specially in this SM-----------------------------------------------------*/

volatile uint8_t timedoutEcat,restartEcatFlag;	
static uint8_t escAPPok;

/*----------------------------External variables----------------------------------------*/
extern TIM_HandleTypeDef htim5;		//From main.c
extern int lan9252; //From lan9252_spi.c
extern volatile uint8_t ecatDMArcvd;	//Defined in LAN9252 library

//	External variables for synchronizing with soes SM
extern volatile uint8_t soesTimeoutFlag;


osTimerId_t timerEcatSOES; // << CHCKME This is used by SOES library
extern _ESCvar ESCvar;		// << Instance of the ESC that are declared within the sampleApp.c
void APP_safeoutput ();	//CHCKME
extern _MBXcontrol MBXcontrol[];
extern uint8_t MBX[];
extern _SMmap SMmap2[];
extern _SMmap SMmap3[];

/*----------------------------smEcat functions----------------------------------------*/
/*
 * @brief Sate Machine for overall task of eCAT interface
 *
 */

void ecat_SM (void * argument) {

	//TEMP for TESTING
	uint16_t ESC_status;
	//FINISHES
	uint8_t error = 0;
	uint8_t firstExec = 1;
	uint32_t rcvdData;

	osStatus_t timerStatus;
	osTimerId_t timerEcatSM,timerEcatSM2;//timerEcatSOES;
	uint32_t timerDelay;
	timerEcatSOES = osTimerNew(timeoutSMCallback_ecat, osTimerOnce, NULL, NULL);
	//timerEcatSM = osTimerNew(timeoutSMCallback_ecat, osTimerOnce, NULL, NULL);
	//timerEcatSM2 = osTimerNew(timeoutSMCallback_ecat, osTimerOnce, NULL, NULL);


	if (timerEcatSM == NULL) {
		__NOP();	//Handle the problem of creating the timer
	}
	if (timerEcatSOES == NULL) {
		__NOP();	//Handle the problem of creating the timer
	}
	while(1) {		//Infinite loop enforced by task execution

		switch (ecat_step) {
		/*--------------------------------------------------*/
			case	ec_config:
				//	action
				if(	ecat_SPIConfig(&hspi4) == FAILED) error++;

				//exit
				if (error) {
					notifyError(ERR_ECAT_INIT);
					error = 0;
					ecat_step = ec_fault;
					} 	//TODO this should be sort of a signal, this should not stop the execution of this SM
				else {
					lan9252 = open ("LOCAL_SPI", O_RDWR, 0);
					ecat_step = ec_checkConnection;
				}

				break;
		/*-------------------------------------------------------*/
			case	ec_checkConnection:
				//	action
				timerDelay = 40u;
				timerStatus = osTimerStart(timerEcatSM, timerDelay);	//Timeout for SOES
				if (timerStatus != osOK) {
					notifyError(ERR_LED_OSTIM); // CHCKME This is a internal OS error.
				}


				osThreadResume(ecatSOESTHandler);	//>> SOES SM starts with higher priority
				osEventFlagsWait(evt_sysSignals,ECAT_EVENT, osFlagsWaitAny, osWaitForever);

				//	exit
				if (restartEcatFlag) {
					notifyError(ERR_ECAT_TIMEOUT);
					restartEcatFlag = FALSE;
					ecat_step = ec_fault;
				}
				else {
					if (osTimerIsRunning(timerEcatSOES)) {	//PENDING This OSTimer could overflow even when there is no timeout due to other threads allocated by the OS
						if (osTimerStop(timerEcatSOES) != osOK) {
							notifyError(ERR_ECAT_OSTIM);
						}
					}
					ecat_step = ec_connected;
				}
					break;
		/*---------------------------------------------------------*/
			case	ec_waitDMA:	// This state is used only if communication is test before soes app has started
				osThreadYield();
				osEventFlagsWait(evt_sysSignals, ECAT_EVENT,osFlagsWaitAny, osWaitForever);

				//exit
				if(ecatDMArcvd) {		//This DMA rcvd can be the full buffer finished transmiting interruption
					ecatDMArcvd = FALSE;
					if(ecatVerifyResp(TEST_BYTE_OFFSET) != FAILED) {
						notifyEvent(EV_ECAT_APP_READY);
						ecat_step = ec_idle;
					}	//TODO this should be improved to use a shared buffer with the data comming from SPI or something similar
					else {
						notifyError(EV_ECAT_APP_NOK);
						ecat_step = ec_fault;
					}
					break;
				} 	//TODO DMAReceived should be changed by interruption

				if(timedoutEcat) {
					notifyError(ERR_ECAT_TIMEOUT);
					timedoutEcat = FALSE;
					ecat_step = ec_fault;
				} 	//The timeout callback function modifies this error flag
				break;
		/*--------------------------------------------------------*/
			case	ec_connected:
				//	entry
				if (firstExec) {
					firstExec = FALSE;
					osThreadResume(ecatSOESTHandler);
				}

				//	action
				if (ESCvar.ALstatus == ESC_APP_OK && !escAPPok) {
					escAPPok = TRUE;
					osEventFlagsSet(evt_sysSignals, ECAT_EVENT);
				}
				else if((ESCvar.ALstatus & ESCop)&&!escAPPok){
					escAPPok = TRUE;
					notifyEvent((uint8_t)EV_ECAT_APP_OP);
				}
				else if((ESCvar.ALstatus & ESCinit)&&!escAPPok){
					notifyEvent((uint8_t)EV_ECAT_APP_NOK);
				}

				osDelay(100u);	// This could be a definition

				//	exit
				if (restartEcatFlag) {
					restartEcatFlag = FALSE;
					notifyError(ERR_ECAT_COMM_LOST);
					ecat_step = ec_fault;
				}

				break;
		/*------------------------------------------------------*/
			case	ec_sleep:
				__NOP();
				osThreadSuspend(ecatSMTHandle);

				break;
		/*--------------------------------------------------------*/
			case	ec_fault:
				//entry

				//action
				escAPPok = FALSE;
				firstExec = FALSE;
				//Task manager should have restarted the SOES Thread
				//osEventFlagsWait(evt_sysSignals,TASKM_EVENT|EV_SOES_RESPAWNED, osFlagsWaitAny, osWaitForever);
				//exit
				ecat_step = ec_restart;
				break;
		/*----------------------------------------------------------*/
			case	ec_restart:
				//action

				ecat_deinit(&hspi4);	// CHCKME whether error prompts due to shared resource
				//updateTaskManFlag = TRUE;
				//osEventFlagsSet(taskManSignals, TASKM_EVENT);	//<<Adds SOES Thread again through a higher priority system task
				//HAL_StatusTypeDef halstatus = HAL_TIM_Base_Stop_IT(&htim5);
				osDelay(3000);		//Waits to restart the communication, meanwhile another task is assessed

				//exit
				ecat_step = ec_config;
				break;
			default:
				__NOP();
			}
	}

	//osThreadTerminate(ecatSMTHandle);

}

/*------------------------------------------Temporary functions(on develop)--------------------------------------------------*/


/* *
 * @brief	This is the timeout callback function for  ECAT
 * */

void timeoutSMCallback_ecat(void * argument) {
	//do something
	uint32_t status;
	HAL_StatusTypeDef halstatus;
	//status = osThreadSuspend(ecatSOESTHandler);	//<< Cannot be called within ISR
	//suspendTaskManFlag = TRUE;
	//status = osEventFlagsSet(taskManSignals, TASKM_EVENT);
	//restartEcatFlag = TRUE;
	halstatus = HAL_TIM_Base_Stop_IT(&htim5);
//	status = osEventFlagsSet(evt_sysSignals, SYS_EVENT);
}
void timeoutSOESCallback_ecat(void * argument) {
	//do something
	//osThreadSuspend(ecatSOESTHandler);
	restartEcatFlag = TRUE;
	//osEventFlagsSet(taskManSignals, TASKM_EVENT);
	__NOP();
}

/* *
 * @brief	This is the timeout callback function specially for SOES. The timers are oneshot, no need for stop them.
 * 				This way the queues are not overflown.
 * */
void timeoutSOESCallback(void * argument) {
	uint32_t status,test;
	test = *(uint32_t *)argument;
	if(test == 1) {
		__NOP();	//Timeout in init
		//Notify event
	}
	else {
		__NOP();	//Timeout while communicating
		//Notify event
	}
	soesTimeoutFlag = TRUE;
	restartEcatFlag = TRUE;		//Flag for taskmanager should be before flag is set.
	//restartTaskManFlag = TRUE;
	//status = osEventFlagsSet(taskManSignals, TASKM_EVENT);

	}

\end{lstlisting}

\begin{lstlisting}[label=lst:soesAPP,caption={Main source code for SOES APP DSM.}]
    /*
    * soesApp.c
    *
    *  Created on: Jul 16, 2020
    *      Author: Carlos Reyes
    *      Comments: Based on the rtl_slavedemo provided within the SOES Library.
    *      	GNU General Public License header copied from the original file
    */
   
   // Comments from original file.
   
   /*
    * Licensed under the GNU General Public License version 2 with exceptions. See
    * LICENSE file in the project root for full license information
    */
   
   //#include <kern.h>			// << Kernel added within  the CMSIS+FreeRTOS
   #include "cmsis_os.h"
   #include "AxisCommHub_definitions.h"
   #include "ecat_slv.h"
   #include "utypes.h"
   //#include "bsp.h"			// << BSAP compatibility already included in the main file, stm32f446ze
   #include "bootstrap.h"
   
   //include for testing
   #include "smEcat.h"
   
   //	External global variables related to DATA
   extern int16_t	gv_temperatureData[NUM_OF_SENSORS];		//	Declared in SMs.c
   
   //	Variables needed for synchronization with SMs
   extern osThreadId_t ecatSOESTHandler;
   extern osTimerId_t timerEcatSOES;
   osTimerId_t timerSOES;
   extern volatile osEventFlagsId_t evt_sysSignals,taskManSignals;
   extern uint32_t *heapObserver0,*heapObserver1,*heapObserver2;
   
   //	Variables needed mainly for this SOES SM
   enum enum_soesStates {s_start, s_init1, s_init2, s_timerset, s_slaveloop, s_sleep, s_nostep, s_error}soes_step;
   volatile uint8_t soesTimeoutFlag;
   
   /* Application variables */
   _Rbuffer    Rb;
   _Wbuffer    Wb;
   _Cbuffer    Cb;
   
    uint16_t masterCommand,masterTest0,masterTest1,masterTest2;
   
   /*-----Test variables-------------------------------------*/
   uint8_t testInputButton;
   uint8_t testOutputLed;
   
   
   /*-----App functions-------------------------------------*/
   
   void cb_get_inputs (void)
   {
       Rb.status += 0xFA;	//	These variables will be updated by other SMs
       Rb.event += 0xFA;
       Rb.error += 0xFA;
       for (uint8_t i = 0; i < NUM_OF_SENSORS;i++) {
           Rb.temp[i] = gv_temperatureData[i]; //
       }
   }
   
   
   void cb_set_outputs (void)
   {
       //	Outputs from the master
       masterCommand = Wb.command;		// In the future this will be a shared memory
       masterTest0 = Wb.testVal0;
       masterTest1 = Wb.testVal1;
       masterTest2 = Wb.testVal2;
   
   }
   
   void soes (void * arg)
   {
       uint32_t time2soes = 0;
       osStatus_t timerStatus;
       uint32_t argument;
   
      /* Setup config hooks */
      static esc_cfg_t config =
      {
         //.user_arg = "/spi0/et1100",
         .user_arg = "LOCAL_SPI",
         .use_interrupt = 0,
         .set_defaults_hook = NULL,
         .watchdog_cnt = 1000,
         .pre_state_change_hook = NULL,
         .post_state_change_hook = post_state_change_hook,
         .application_hook = NULL,
         .safeoutput_override = NULL,
         .pre_object_download_hook = NULL,
         .post_object_download_hook = NULL,
         .rxpdo_override = NULL,
         .txpdo_override = NULL,
         .esc_hw_interrupt_enable = NULL,
         .esc_hw_interrupt_disable = NULL,
         .esc_hw_eep_handler = NULL
      };
   
      // This is the soes sm
   
   
      soes_step = s_start;
   
      while(1) {
          switch (soes_step) {
          /*--------------------------------------------------------*/
          //	Dummy state
          case s_start:
              //	entry:
              __NOP();
              //	exit:
              soes_step = s_init1;
              break;
          /*--------------------------------------------------------*/
          case  s_init1:
              //	entry:
   
              if (timerSOES != NULL) {
                  //	Timer not null might mean that it came from an strange state
                  __NOP();	//Handle error
                  soes_step = s_error;
                  break;
              }
              //	Timer for the init state sm, needs to be null at the beginning
              argument = 1u;
              timerSOES = osTimerNew(timeoutSOESCallback, osTimerOnce, &argument, NULL);
              if (timerSOES == NULL) {	//Normal check-up of timer after creation
                  __NOP();	//Handle error
                  soes_step = s_error;
                  break;
              }
   
              timerStatus = osTimerStart(timerSOES, 1000u);
              if (timerStatus != osOK) {
                  __NOP();		//Handle error
                  soes_step = s_error;
                  break;
              }
   
              ecat_slv_init (&config);
   
              //	exit:
              if(osTimerIsRunning(timerSOES)) {
                  timerStatus = osTimerStop(timerSOES);
                  timerStatus = osTimerDelete(timerSOES);
                  if (timerStatus != osOK) {
                      __NOP();	//Handle error
                      soes_step = s_error;
                      break;
                  }
              }
              if (soesTimeoutFlag) {	//	soes loop left by timeout
                  //	Handle error
                  soes_step = s_error;
                  break;
              }
              soes_step = s_init2;
              break;
          /*--------------------------------------------------------*/
          case  s_init2:
              //	entry:
              osEventFlagsSet(evt_sysSignals, ECAT_EVENT|EV_ECAT_ESC_INIT);	//TODO << Check with heap observer that two flags are set
              osThreadSuspend(ecatSOESTHandler);	// << Resumed by Ecat SM in State: Connected. This could be an event
              //	exit:
              argument = 2u;
              timerSOES = osTimerNew(timeoutSOESCallback, osTimerOnce, &argument, NULL);
              if (timerSOES == NULL) {
                  __NOP();	//Handle error
                  soes_step = s_error;
                  break;
              }
              //	Starting soes app timing
              time2soes = osKernelGetTickCount();	//PENDING This variable could be used for improved refresh cycle control
              soes_step = s_timerset;
              break;
          /*--------------------------------------------------------*/
          case  s_timerset:
              //	entry:
              timerStatus = osTimerStart(timerSOES, 1000u);
              if(timerStatus != osOK) {
                  __NOP();	//Handle error
                  soes_step = s_error;
                  break;
              }
              heapObserver1 = timerSOES;
   
              //	exit:
              soes_step = s_slaveloop;
              break;
          /*--------------------------------------------------------*/
          case  s_slaveloop:
              //	entry:
              ecat_slv();
              //	exit:
              if(osTimerIsRunning(timerSOES)) {
                  timerStatus = osTimerStop(timerSOES);
                  if (timerStatus != osOK) {
                      __NOP();	//Handle error
                      soes_step = s_error;
                      break;
                  }
              }
              if (soesTimeoutFlag) {	//	soes loop left by timeout
                  //	Handle error
                  soes_step = s_error;
                  break;
              }
              soes_step = s_sleep;
              break;
          /*--------------------------------------------------------*/
          case  s_sleep:
              //	entry:
              osDelay(SOES_REFRESH_CYCLE);
              // A better refresh cycle control could be achieved by using osDelayUntil();
              //	exit:
              if (soesTimeoutFlag) {	//	soes loop left by timeout
                  //	Handle error
                  soes_step = s_error;
                  break;
              }
              soes_step = s_timerset;
              break;
          /*--------------------------------------------------------*/
          case  s_error:
              __NOP();	//	Handle the error
              timerStatus = osTimerDelete(timerSOES);
              if (timerStatus != osOK) {
                  __NOP();	//Handle error
              }
              //osDelay(100);	//TEST
              osThreadSuspend(ecatSOESTHandler); // this should wait for event handler or something to restart
              break;
          /*--------------------------------------------------------*/
          default:
              soes_step = s_error;
              //soesTimeoutFlag = FALSE;
          }	//	End switch
      }	//	End while
   }
\end{lstlisting}

\begin{lstlisting}[label=lst:led,caption={Main source code for LED DSM.}]
    /*
    * smLed.c
    *
    *  Created on: Jun 25, 2020
    *      Author: Carlos Reyes
    */
   
   #include "SMs.h"
   #include "smLed.h"
   //#include "WS2812_Lib_MultiChannel.h"
   
   osTimerId_t refreshLed,timeoutLed;	//Pending: this could be local or static
   static volatile uint8_t boolTimeoutLed,boolRefreshTimeoutLed;	//PEnding is this necessary?
   //	Debug variables
   volatile uint32_t currentFlags1,currentFlags2;
   
   //External variables
   extern TIM_HandleTypeDef *ledCH1,*ledCH2,*ledCH3,*ledCH4;	//	Declared in WS2812 Libraries
   
   /*
    * @brief Sate Machine for overall task of LED RINGS controlled by PWM
    *
    */
   
   void ledRings_SM (void * argument) {
       uint8_t chsetupOK[NUM_OF_LEDRINGS];
       uint8_t error = 0;
       uint32_t temp32,eventStatus;
       osStatus_t timerStatus;
   
   
       timeoutLed = osTimerNew(timeoutCallback_led, osTimerOnce, NULL, NULL);
       refreshLed = osTimerNew(refreshCallback_led, osTimerOnce, NULL, NULL);
       if (timeoutLed == NULL) {
           __NOP();	//Debug the error.
       }
   
       while(1) {
   
           switch (led_step) {
           /*---------------------------------------------------------*/
               case	L_config:		//Initializes and links the handlers with WS2812 library
                   //	action
                   if (NUM_OF_LEDRINGS > 0) {
                       if(ledDMA_configCh(1,&htim8) != FAILED)
                           chsetupOK[0] = TRUE;
                       else {
                           chsetupOK[0] = FALSE;
                           error++;
                       }
                   }
                   if (NUM_OF_LEDRINGS > 1) {
                       if(ledDMA_configCh(2,&htim3) != FAILED)
                           chsetupOK[1] = TRUE;
                       else {
                           chsetupOK[1] = FALSE;
                           error++;
                       }
                   }
                   //if (NUM_OF_LEDRINGS > 2)
                   //if (NUM_OF_LEDRINGS > 3)
   
   
                   //	exit
                   if (error) {
                       notifyError(ERR_LED_INIT);	//Pending This should notify over ECAT but not stop the overall SM
                       led_step = L_restart;
                   }
                   else {
                       error = 0;
                       //Set the Effects
                       setColorState(color_preop);
                       temp32 = SYS_EVENT|(EV_LED_DSM_INIT<<SHIFT_OFFSET);
                       osEventFlagsSet(evt_sysSignals, temp32);	//	System notification
                       led_step = L_send;
                   }
   
                   break;
           /*----------------------------------------------------------*/
               case L_send:
                   //	action
                   for (uint8_t i = 1; i <= NUM_OF_LEDRINGS; i++) {
                       if (ledDMA_send(i) == FAILED)
                           notifyError(ERR_LED_SEND);
   
                   }
                   timerStatus = osTimerStart(timeoutLed, (uint32_t) 1000U);	//Timeout for DMA
                   if (timerStatus != osOK) {
                       notifyError(ERR_LED_OSTIM); //	This is a internal OS error.
                   }
   
                   //exit
                   led_step = L_waitEvent;
                   break;
           /*--------------------------------------------------------------*/
               case	L_waitEvent:
                   //	action
                   osEventFlagsWait(evt_sysSignals, LED_EVENT, osFlagsWaitAny, osWaitForever);
   
                   //	exit
   
                   if (boolTimeoutLed) {
                       if (osTimerIsRunning(timeoutLed)){
                           if (osTimerStop(timeoutLed) != osOK) {
                               __NOP();//Handle internal OS  error
                               notifyError(ERR_LED_OSTIM);
                           }
                       }
   
                       boolTimeoutLed = FALSE;
                       notifyError(ERR_LED_TIMEOUT);
                       led_step = L_restart;
                       break;
                   }
                   else if(dmaLed1_rcvd && dmaLed2_rcvd) { //	SAFE: Only updates a color state if no timeout
                       if (osTimerIsRunning(timeoutLed)) {
                           if (osTimerStop(timeoutLed) != osOK) {
                               __NOP();//Handle internal OS error
                               notifyError(ERR_LED_OSTIM);
                           }
                       }
   
                       dmaLed1_rcvd = 0;
                       dmaLed2_rcvd = 0;
   
                       led_step = L_updateColorState;
                       break;
                   }
   
                   break;
           /*------------------------------------------------------------*/
               case	L_updateColorState:
                   //	action
                   if (errorFlag) {
                       setColorState(color_error);
                   }
                   else if (initFlag) {
                       __NOP();	//	Keeps the default color
                   }
                   else if (ecatCMDFlag) {
                       setColorState(color_custom);
                   }
                   else if (warningFlag) {
                       setColorState(color_warning);
                   }
                   else if (normalFlag) {
                       setColorState(color_normal);
                   }
   
                   //	exit
                   //notifyEvent(LED_UPDATED);
                   led_step = EFFECTS_ACTIVATED ? L_updateEffect : l_waitRefresh;
   
                   break;
           /*------------------------------------------------------------*/
               case	L_updateEffect:
                   //	action
   //				if (led_effectRateUpdt()) {	This function checks whether the current effect needs to be updated
   //					__NOP();	//PENDING Effects are a future future
   //				}
   
                   //	exit
                   led_step = l_waitRefresh;
                   break;
           /*-----------------------------------------------------------*/
               case	l_waitRefresh:
                   // action
                   if(osTimerStart(refreshLed, (uint32_t)PWM_REFRESH_PERIOD)!= osOK) {
                       __NOP(); //Handle the OS TIMER starting error.
                       notifyError(ERR_LED_OSTIM);
                       led_step = L_restart;
                       break;
                   }
                   //
                   eventStatus = osEventFlagsGet(evt_sysSignals);
                   osEventFlagsWait(evt_sysSignals, LED_EVENT, osFlagsWaitAny, osWaitForever);
   
                   //exit
   
                   //Refreshing time is already elapsed
                   if (boolRefreshTimeoutLed) {
                       if(osTimerIsRunning(refreshLed)){
                           if(osTimerStop(refreshLed)!= osOK) {
                               __NOP();	//Only for error debugging
                               notifyError(ERR_LED_OSTIM);
                               led_step = L_restart;
                           }
                       }
   
                       boolRefreshTimeoutLed = FALSE;
                       led_step = L_send;
                   }
   
                   break;
           /*--------------------------------------------------------*/
               case	L_restart:		//After timeout or error
   
                   if (osTimerIsRunning(timeoutLed))
                       timerStatus = osTimerStop(timeoutLed);
   
                   if (timerStatus != osOK) {
                       __NOP(); //PENDING Handle the deletion error
                   }
   
                   for (uint8_t i = 1; i<=NUM_OF_LEDRINGS; i++) {
                       ledDMA_restartCH(i);
                   }
   
                   //exit
                   led_step = L_config;
   
                   break;
           /*----------------------------------------------------------*/
               default:
                   __NOP();
               }
       }
   
       //osThreadTerminate(ledRingsTHandle);	//If at any moment the cp reaches out of the while loop
   
   
   }
   
\end{lstlisting}

\begin{lstlisting}[label=lst:tempApp,caption={Main code for Temperature App.}]
    /*
    * owApp.c
    *
    *  Created on: Aug 19, 2020
    *      Author: Carlos Reyes
    *      Based on owApp.c from
    * 			Author:          Tilen MAJERLE <tilen@majerle.eu>
    * 			Version:         v3.0.0
    */
   
   #include "AxisCommHub_definitions.h"
   #include "cmsis_os.h"
   #include "lwow.h"
   #include "devices/lwow_device_ds18x20.h"
   #include "scan_devices.h"
   //#include "stdio.h"
   
   //Creating a new one-wire instance
   
   extern const lwow_ll_drv_t lwow_ll_drv_stm32_hal;
   lwow_t ow_inst;
   lwow_rom_t rom_ids[20];		//ROM IDs are stored here
   size_t rom_found;
   
   //Definition from MAIN
   extern UART_HandleTypeDef huart3;
   
   //Definition from SM
   extern int16_t	gv_temperatureData[NUM_OF_SENSORS];
   
   //Functions definition
   static void owApp(void* arg);
   
   const osThreadAttr_t oneWireTask_attr = {
           .priority = osPriorityAboveNormal1,
           .stack_size = 512
   };
   
   /*
    * 	@brief Simple function to spawn the application thread
    *
    */
   void initOwApp(void) {
       ow_inst.arg = &huart3;
       osThreadNew(owApp, NULL, &oneWireTask_attr);
   }
   
   /**
    * @brief           Application thread
    * @param[in]       arg: Thread argument
    */
   static void owApp(void* arg) {
       float avg_temp;
       size_t avg_temp_count;
   
       /* Initialize 1-Wire library and set user argument to NULL */
       lwow_init(&ow_inst, &lwow_ll_drv_stm32_hal, &huart3);
   
       /* Get onewire devices connected on 1-wire port */
       do {
           if (scan_onewire_devices(&ow_inst, rom_ids, LWOW_ARRAYSIZE(rom_ids), &rom_found) == lwowOK) {
               printf("Devices scanned, found %d devices!\r\n", (int)rom_found);
           } else {
               printf("Device scan error\r\n");
           }
           if (rom_found == 0) {
               osDelay(1000);
           }
       } while (rom_found == 0);
   
       if (rom_found > 0) {
           /* Infinite loop */
           while (1) {
               printf("Start temperature conversion\r\n");
               lwow_ds18x20_start(&ow_inst, NULL);      /* Start conversion on all devices, use protected API */
               osDelay(1000);                      /* Release thread for 1 second */
   
               /* Read temperature on all devices */
               avg_temp = 0;
               avg_temp_count = 0;
               for (size_t i = 0; i < rom_found; i++) {
                   if (lwow_ds18x20_is_b(&ow_inst, &rom_ids[i])) {
                       float temp;
                       uint8_t resolution = lwow_ds18x20_get_resolution(&ow_inst, &rom_ids[i]);
                       if (lwow_ds18x20_read(&ow_inst, &rom_ids[i], &temp)) {
                           printf("Sensor %02u temperature is %d.%d degrees (%u bits resolution)\r\n",
                               (unsigned)i, (int)temp, (int)((temp * 1000.0f) - (((int)temp) * 1000)), (unsigned)resolution);
                           gv_temperatureData[i] = (uint16_t) temp;
                           avg_temp += temp;
                           avg_temp_count++;
                       } else {
                           printf("Could not read temperature on sensor %u\r\n", (unsigned)i);
                       }
                   }
               }
               if (avg_temp_count > 0) {
                   avg_temp = avg_temp / avg_temp_count;
               }
               printf("Average temperature: %d.%d degrees\r\n", (int)avg_temp, (int)((avg_temp * 100.0f) - ((int)avg_temp) * 100));
           }
       }
       printf("Terminating application thread\r\n");
       osThreadExit();
   }
\end{lstlisting}



